# Coursework 2, Checkers our code
In this coursework, we will be getting used to the idea of using and writing tests when developing code. We have provided the beginnings of an implementation for the board game draughts which you will be adding to. Your task is **not** to complete the model, but instead to develop some tests so that we can check our progress.

***
**TODO:** Download and unzip the following code, and add it to a new repository:

* [cw2.zip](cw2.zip)

***

#Ant
When you open up the draughts root project folder you will notice a number of folders making up the project structure. These folders help us to organise the project and they are:

* src: Contains the .java source files
* res: Contains the resources (images etc.) for the project
* doc: Contains documentation for the project, generated by [Javadoc](http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javadoc.html).
* lib: Contains the libraries we are using, such as JUnit.
* ant: Contains a build-tool named ant
* tests: Contains JUnit tests.

As you can see, we now have a larger project including resources. As such, compiling the project using javac would be laborious. Instead we will be using a java build-tool named [ant](http://ant.apache.org/) to do this for us automatically.

We have included ant in the project, but for future reference you can find the latest version [here](http://ant.apache.org/bindownload.cgi) and the documentation is included in the `ant/manual` directory, so navigate to `ant/manual/index.html` in a browser to use it. If you work in the labs you may need to change permissions to make the ant binary executable.

Ant uses a file named `build.xml` to specify a number of targets which allow us to specify common tasks such as compilation, running, testing, etc. Below is the `make_folders` target which is used by various other targets to create the directories they require.
```
<target name="make_folders" depends="clean">
  <mkdir dir="${bin.dir}"/>
  <mkdir dir="${classes.dir}"/>
  <mkdir dir="${jar.dir}"/>
  <mkdir dir="${doc.dir}"/>
</target>

```
The directories it creates are referenced by aliases which are defined at the top of the file. For example `${bin.dir}` means `bin` and `${classes.dir}` is defined as `${bin.dir}/classes`. `bin/classes` is the directory that our files are compiled to when we run the `compile` target (or any that depend on `compile`).

Notice that this target `depends` on the target `clean`. This is an especially useful target we have defined. It removes the bin directory and its contents so that we know we are compiling our code to a clean folder.

***
**TODO:** Use the `make_folders` target by running `./ant/bin/ant make_folders` from the root directory (where the `build.xml` file is).

***

We will be using the `test` ant target which you should also try out now. This target compiles the project and runs the JUnit tests found in the `tests` folder.

***
**TODO:** Run `./ant/bin/ant test`.

***

#Draughts
##Part 1
As we said in the introduction, this project is based on the board game Draughts. You should begin by making sure you know how the game works.

***
**TODO:** Familiarise yourself with the rules of draughts. [The wikipedia page](https://en.wikipedia.org/wiki/English_draughts#Gameplay) for draughts nicely outlines the rules of the game (there are more than you might imagine!).

***

Inside the src directory there is a folder called `draughts` which contains the classes for our game. The game is run from `Draughts.java` but we are more interested in the model which takes care of how the game progresses. Look at the code in `DraughtsModel.java` and try to get an idea of what's going on. What happens when the `start` method is called? How are moves played? Hint: trace the methods called in the model to find out. You may also want to look at some of the other files in the `draughts` folder such as `Colour`, `Piece` and `Move`. We'll wait here for you.

*If you are unsure about which classes Java contains or what methods a class has, it's always a good idea to do a Google search to find out. If you are not sure about something in the project then the provided `javadocs` in the docs folder are a good place to look.*

Done? Good. One of the methods you hopefully noticed in the model was the `getPiece` method:
```java
public Piece getPiece(int x, int y) {
    for (Piece piece : pieces) {
        if (piece.getX() == x && piece.getY() == y) return piece;
    }
    return null;
}
```
This method is intended to fetch us the `Piece` object at the location we specify, if it exists. It looks like it does the job but we should write a test just to make sure. We looked at JUnit tests briefly in the last coursework so you should have some idea how they work. Inside `tests/ModelTests.java` there are a few already implemented, along with some helper classes. Lets add another one to test the `getPiece` method.

Our approach will be similar to the tests you have already seen, we will set up a situation where we can call the method we are testing and then compare the result with what we expect. We will begin by writing the method declaration (remembering the @Test annotation!).
```java
@Test
public void testCorrectPieceIsReturned() {
}
```
The model stores `Piece` objects in a global set named `pieces` so we must begin by initialising this set with some `Piece` objects of our choosing. We can do this by creating a `DraughtsModel` object and using the `DraughtsModel(String gameName, Player player, Colour currentPlayer, Set<Piece> pieces)` constructor. The `gameName`, `player` and `currentPlayer` arguments do not matter but for the `pieces` arguement we will pass in a set containing a single `Piece` object at location (3,5).
```java
@Test
public void testCorrectPieceIsReturned() {
    Set<Piece> pieces = new HashSet<Piece>();
    Piece piece = new Piece(Colour.Red, 3, 5);
    pieces.add(piece);

    DraughtsModel model = new DraughtsModel("Test", null, Colour.Red, pieces);
}
```
Great! Now we have set up our model all that we need to do is call the `getPiece` method at the location (3,5) and verify that this is the `Piece` we expect.
```java
@Test
public void testCorrectPieceIsReturned() {
    Set<Piece> pieces = new HashSet<Piece>();
    Piece piece = new Piece(Colour.Red, 3, 5);
    pieces.add(piece);

    DraughtsModel model = new DraughtsModel("Test", null, Colour.Red, pieces);

    assertEquals("The correct piece should be returned", piece, model.getPiece(3, 5));
}
```
We now have a test which verifies that our `getPiece` method works in one situation, clearly we cannot test every situation but it is normally a good idea to have a few assertions. We should try to consider every way that our method *could* be failing and make sure we check those situations.

***
**TODO:** Add a test (or more than one) to `tests/ModelTests.java` which ensures that the `getPiece` method in `src/draughts/DraughtsModel.java` works correctly.

***

##Part 2
The `removePiece` method in the model checks to see if a player has just jumped over an opponents piece, if so it returns true. The method takes two arguments, `position` which is the players position *before* it made a move, and `destination` which is the players location *after* making a move. We use these pieces of information to determine if a jump has occurred.
```java
protected boolean removePiece(Point position, Point destination) {
    int x = (int) (destination.getX() - position.getX());
    int y = (int) (destination.getY() - position.getY());
    if (x == 2) {
        x = (int) (position.getX() + (x / 2));
        y = (int) (position.getY() + (y / 2));
        Piece piece = getPiece(x, y);
        pieces.remove(piece);
        return false;
    }
    return true;
}
```
We want to write a test to see if the `removePiece` method is working correctly, however, the method is protected. This means that only classes that inherit from `DraughtsModel` or are in the same package, can access `removePiece`. This is a common issue when writing tests, we want to keep access to our code as tight as possible but we also need to be able to use it in order to write our tests.

One possibility is to bundle this test into a larger one that calls `start`, which is public, and then check the state of the game is correct when the game is over. But this hides a lot of what is going on in the model so if there *is* a problem, we have no idea where it lies.

Instead we are going to use the helper class `TestModel` in `ModelTests.java`. This class extends `DraughtsModel` and gives us more access to `DraughtsModel`'s methods. The `testCurrentPlayerUpdatesCorrectly` test also uses the `TestModel` so refer to that if you get stuck.

***
**TODO:** Using TestModel, add a test to see if the `removePiece` method works as it should.

***

The test you have just written should be failing because the `removePiece` method is actually implemented slightly incorrectly. if you have written a good test you should have an idea of wha is going wrong. If not, try to improve your test or consider writing some additional tests that evaluate a different situation.

***
**TODO:** Fix the `removePiece` method in the model.

***

#Part 3
The `play` method is not fully implemented but we want to write some tests so that we can see what is going on whilst we finish it. You should write the tests using the available methods as if they were fully implemented. Use the `TestModel` class as we did for the `removePiece` method and remember, a good test is one that isolates what is being tested as much as possible.

*In these tests we do not care if a move is possible, only that it is played correctly.*

***
**TODO:** Add a test that verifies that the piece is moved to the correct location when a move is played (this test will fail with the current model).

***

**TODO:** Add a test that verifies that if a jump move takes place, the taken piece is removed  (this test will fail with the current model).

***

#Part 4
One of the first methods to be called when we create the model is `initialisePieces`. This adds `Piece` objects to the `pieces` set at the start of the game.

***
**TODO:** Make sure you know how the game pieces are set up in draughts and write a test to verify `initialisePieces` does so correctly, white pieces should be at the top of the board (this test will fail with the current model).

***
